极客时间学习笔记之对象的比较，拷贝

# '==' VS 'is'

'=='是比较对象之间的值是否相等；'is'是比较对象是否指向同一块地址；实际工作中使用'=='的次数会比'is'多，因为我们更关心两个对象的值，而非地址。当比较一个变量与一个单例时，通常会使用'is'，比如检查一个变量是否为‘None’。比较操作符'is'的速度效率通常优于'=='。因为'is'不能被重载，就仅仅是比较两个变量的id而已。python中每个对象的身份标识通过id(object)获得。'=='操作符，执行a == b相当于执行a.__eq__(b),python中大部分数据类型都会重载__eq__，这个函数的内部处理很复杂，对于列表，__eq__会遍历列表中的元素，比较它们的顺序和值是否相等。

python内部会对-5到256的整型维持一个数组，起到一个缓存的作用，每次创建一个-5到256范围内的整形数字时，python都会从数组中返回相对应的引用，而不是重新开辟一块儿新的内存空间。

# 浅拷贝和深度拷贝

l1 = [1, 2, 3]
l2 = list(l1)

s1 = set([1, 2, 3])
s2 = set(s1)

如上面的代码，l2是l1的浅拷贝，s2是s1的浅拷贝，浅拷贝是生成一个新的对象，里面的元素是原来对象子元素的引用；对于可变的序列可以通过切片来完成浅拷贝，如下面的代码，
l1 = [1, 2, 3]
l2 = l1[:]

python中的copy.copy()，适用于任何数据类型，
import copy
l1 = [1, 2, 3]
l2 = copy.copy(l1)

对于元组使用tuple(),或者切片操作':'不会创建一份浅拷贝，相反它会返回指向相同元组的引用。
浅拷贝在原对象的元素可变的时候，会有一些副作用，看下面的例子，
l1 = [[1, 2], (30, 40)]
l2 = list(l1)
l1.append(100)
l1[0].append(3)

l1
[[1, 2, 3], (30, 40), 100]

l2
[[1, 2, 3], (30, 40)]

l1[1] += (50, 60)
l1
[[1, 2, 3], (30, 40, 50, 60), 100]

l2
[[1, 2, 3], (30, 40)]

要想完整的拷贝一个对象，就得用深度拷贝。深度拷贝，是重新分配一块儿内存，创建一个对象，并将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。所以新对象和原对象没有关联。
深度拷贝，如果被拷贝的对象中存在指向自身的引用，那么程序容易陷入无限循环。

import copy
x = [1]
x.append(x)

x
[1, [...]]

y = copy.deepcopy(x)
y
[1, [...]]

上面的这个例子，列表x中有指向自身的引用，因此x是一个无限嵌套的列表，但是深度拷贝后，程序没有出现stack overflow。这是因为深度拷贝函数会维护一个字典，记录已经拷贝的对象与其id，拷贝过程中，如果字典中已经存储了将要拷贝的对象，则从字典中直接返回。
但是这个时候调用 x == y就会直接出错了，因为进入了无限循环。






