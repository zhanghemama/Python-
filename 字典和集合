字典是无序的元素的组合，是可变的。 相比于列表和元组，字典的效率更高，查找，添加，删除都可以在常数时间复杂度内完成。
集合效率与字典相同，也是无序的，但是他只有value，没有key。
字典可以直接用key来索引。如果不存在会抛异常，也可以用get(key, default)来索引，存在key就返回对应的value，不存在就返回null。
集合不支持索引操作，因为集合本质上是哈希表，与列表不同。
用value in dict/set可以判断一个值是否存在与字典和集合中。
字典和集合的内部结构是哈希表。字典这张表存储了哈希值，键和值这三个元素，集合是哈希值和值。
老版本python字典的存储结构如下：
--+-------------------------------+
  | 哈希值 (hash)  键 (key)  值 (value)
--+-------------------------------+
0 |    hash0      key0    value0
--+-------------------------------+
1 |    hash1      key1    value1
--+-------------------------------+
2 |    hash2      key2    value2
--+-------------------------------+
. |           ...
__+_______________________________+

随着哈希表的扩张，他会变得很稀疏；哈希表为了保证其操作的有效性（查找，添加，删除等等），都会overallocate（保留至少1/3的剩
余空间），但是很多空间其实都没有被利用，因此很稀疏。下面这个字典，
{'name': 'mike', 'dob': '1999-01-01', 'gender': 'male'}
其会被存储为：
entries = [
['--', '--', '--']
[-230273521, 'dob', '1999-01-01'],
['--', '--', '--'],
['--', '--', '--'],
[1231236123, 'name', 'mike'],
['--', '--', '--'],
[9371539127, 'gender', 'male']
]
显然很浪费空间。为了提高空间利用率，现在的哈希表会把索引和哈希值，键，值分开，也就是下面的结构，
Indices
----------------------------------------------------
None | index | None | None | index | None | index ...
----------------------------------------------------

Entries
--------------------
hash0   key0  value0
---------------------
hash1   key1  value1
---------------------
hash2   key2  value2
---------------------
        ...
---------------------
刚刚的例子，存储结构就变成，
indices = [None, 1, None, None, 0, None, 2]
entries = [
[1231236123, 'name', 'mike'],
[-230273521, 'dob', '1999-01-01'],
[9371539127, 'gender', 'male']
]
这样空间利用率就有了很大的提高。

字典的插入操作：每次向字典中插入一个元素的时候，python会先计算哈希值，算出这个元素应该插入哈希表中的位置，若这个位置空着就直
接插入，若已经存在，则比较这两个元素的哈希值和键值，都相同就覆盖原来的元素；有一个不同就产生哈希冲突了，python会继续寻找位置。
字典的查找操作，python根据哈希值找到某个元素所处的位置，然后比较该位置的元素的哈希值和键值与要查找的元素是否相同，相同就返回，
否则继续查找，知道找到或返回null。
字典删除某个元素，对于删除操作，字典会先暂时对这个位置的元素赋一个特殊的值，等待下次重新调整哈希表的时候再将其删除。
哈希表的冲突，会降低字典和集合操作的速度。因此为了保证高效性，python通常会保证至少有1/3的剩余空间。随着元素的不停
插入，当剩余空间小于1/3的时候，python就会重新获取更大的空间，扩充哈希表，这个时候表内所有的元素都会被重新排放。
虽然哈希表的冲突和哈希表大小的调整，会导致速度下降，但是这种情况发生的次数很少。所以平均情况下，让能保证插入，查
找，删除的时间复杂度是O(1)。
字典的键值可以是列表吗？答案是NO。列表可变，但是键值不可变，所以不行。
